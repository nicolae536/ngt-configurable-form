



Slide 2: Application development
	We are all developers and we build applications applications which usually start very small
	and after some time they get very big and very heavy in functionality, which takes us to specific
	problems
Slide 3: Problems
	Application bundle size-> which get bigger and bigger
	Components maintenance -> we have a lot of components which must be mainteined
	User responsiveness -> which defines the first feeling to our application, and concistency over screens
Slide 4: Forms
	If we take a look to a application we can see that a big part of it is forms defining specific user flows.
	Which leads us to big applications where we have thousends of them.
--> image with forms in applications
--> image to simbolise big enterprise app with a lot of fields
Slide 5: Forms problems
	The problems with forms  is that they tend be very specific in different user flows.
	And your implementation for one component might be totally different then in other similar
	components just becase a step in the user flow is different.
	They also need a lot of maintenance which leads to specific bugs in specific area
--> image with app splitting in modules and sizes
Slide 6: Solution
	Render forms using json files
	- this can be very nice and will decrease our bundle size
	- also it can decrease the maintenance for our components
	- but it gets trickier when you need to define user flows and rules/links between fields
--> brief image with the configuration
Slide 7: Proposal
	So my proposal on how we can manage this easier using json configuration is to define a schema
	on how we can load elements and define them using configuration.
Slide 8: Architectural pattern.
	So in my schema I chose to inline all my elements in an array defining static configurations
	Fields which might define the ui for those elements.
	In forms we usually have groups and group elements.
	For simplicity I decided to split those in two array to avoid any confusion.
-> Architectural schema and explain on it
Slide 9: 
	We have a baseElement which take our common methods and properties
 	a group can have validation/disabled/value also an group element can have those/
Slide 10: 
	And from this baseElement we create another two entityes which are GroupUiElement
	and UiElement first one for groups the second one ui elements like fields
-->	Simple example with one element
Slide 11: 
	So what else do we need after we have the elements we need to define a "layout" or a representation
	for how will they be aligned in the ui
	For they layout I chosen a simple representation
-> show simple layout example and explain it
Slide 12:
	And the tricky part remains. Field linking
	How we can think of this.
	Two ways -> 1. one element changes another
	or the opposite way aground -> the element listen to the other elements and change itself
Slide 13:
	I worked with both and I found that the second one is much easier to maintain
	To listen from one element to multiple elements and define how you should changed.
	Also a important thing to links is that they should be resolved in only one pass.
	For example a value changes a link is triggered for another element that element should be able to
	define itself in a simple iteration
	"Like in life is easier to depend on yourself not to the others."
Slide 14: Summary over those discussed
-->	Show again the architecture and explain it
	So we have a base element which is extended in two specific elements
	
	GroupUiElement
	UiElements
	Layout which is a representation of the view containing all possible elements
	And links which define a change over time depending on a value from another field
	
	All those described define our schema
Slide 15: Angular implementation
--> 	Explain how the schema works in current implementation
	So we take all the UiElements, GroupUiElement and wrap them objects
	We cache all of them to be easy accessible
	Build the first layout (representation in memory of the UiElements)
	Normalise using the current value for form if any
	We travers the links and check with the current elements values if we need to change the layout
	Render the layout -> view render
Slide 16: Show demos
--> 	For all what I described I have an implementation using @angular>4.x and material desing
	I chased the ReactiveFormsModule since I define all my elements using code
	And I have built a component to support the described functionality
	So this is an example for simple layout
	We can add validations to it/and also custom validations using DI
	We can link data providers to select/autocomplete elements
	And the one which all of us like we can link fields (select with autocomplete)
	Show/Hide fields, change validations example
Slide 17: But there is even more 
	Some applications have complex state management 
	Multiple forms binded to same model
	The most popular pattern for this is redux. 
	I tried to keep to component in the one way data flow to be easy integrable with redux pattern
Slide 18: Future improvements
	Unit and E2e testing
	Add arrays -> (array of group/ui elements)
	A bundle with the component in npm as (ngt-configuable-form).
Slide 19: Benefits
	Only one component manages the forms in our app
	Easy to track bugs related to forms
	Fast ui prototyping
	Less js code to the client
	
	

	
	
	
	


































<ngt-configurable-form [formConfig]="config"
                           [fieldsDataProviders]="dataProviders">
    </ngt-configurable-form> 
So as examples for you I have implemented this using material design components. As the base for now I have the form configuration which can handle basic field linking, basic validations and data change events.
As the redux part what I noticed in the last time is that [(value)] and cycles in components like 
set value(myVal: any) {
	this.onMyValChanges.emit(myVal);
}
(onMyValChanges)=�emitActionValChanges($event)�

Are not really friendly with redux pattern in angular because will tringger at least two change detection cycles 
set value(myVal: any) {
	this.onMyValChanges.emit(new MyValue(myVal));
}

(onMyValChanges)=�emitActionValChanges($event)�
Will get you a nice infinite cycle. So what I wold like to do is create a basic integration with ngrx to prove the this component is fully compatible with redux pattern.



Slides


<!--<section>-->
        <!--<h3>Usable inputs and outputs</h3>-->
        <!--@Input() fieldsDataProviders: Dictionary&lt;Observable&lt;any&gt;&gt;-->
        <!--<p>In case we need to fetch some data to a field (select | autocomplete) using async calls</p>-->
        <!--@Input() fieldsListenersMap: Dictionary&lt;Subject&lt;any&gt;&gt;-->
        <!--<p>In case we need to listen to a value change on some input</p>-->
        <!--@Input() updateValues: Dictionary&lt;any&gt;-->
        <!--<p>Updates form controls with new values</p>-->
        <!--</section>-->
        <!--<section>-->
        <!--<h3>Usable inputs and outputs</h3>-->
        <!--@Input() formConfig: Observable&lt;IFormConfig> | IFormConfig;-->
        <!--<p>The current configuration</p>-->
        <!--@Output() onValueChange: EventEmitter&lt;Dictionary&lt;any&gt;&gt;-->
        <!--<p>Each time a value changes this event is triggered</p>-->
        <!--@Output() onValidityMapChange: EventEmitter&lt;Dictionary&lt;boolean&gt;&gt;-->
        <!--<p>Each time a validity of a control is updated a new map is generated</p>-->
        <!--</section>-->
        <!--<section>-->
        <!--<h3>Usable inputs and outputs</h3>-->
        <!--@Output() onConfigurationChange: EventEmitter&lt;IFormConfig&gt;-->
        <!--<p>Configuration changes if there is defined a link relation the configuration might change</p>-->
        <!--@Output() onValidityChange: EventEmitter&lt;boolean&gt;-->
        <!--<p>Form valid state updates</p>-->
        <!--</section>-->